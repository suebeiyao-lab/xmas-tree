<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI手势交互：高级圣诞幻境</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050a05; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #d4af37; /* Metallic Gold */
            z-index: 10;
            pointer-events: none;
        }

        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 100;
        }

        button, label {
            background: rgba(184, 134, 11, 0.2);
            border: 1px solid #d4af37;
            color: #d4af37;
            padding: 10px 20px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s;
            pointer-events: auto;
        }

        button:hover { background: #d4af37; color: #000; }

        #video-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border: 2px solid #d4af37;
            border-radius: 8px;
            overflow: hidden;
            transform: scaleX(-1); /* 镜像画面 */
        }

        video { width: 100%; height: 100%; object-fit: cover; }
        #status { font-weight: bold; text-shadow: 0 0 10px rgba(212, 175, 55, 0.8); }
    </style>
</head>
<body>

<div id="ui-overlay">
    <h2>高级手势控制 3D 圣诞树</h2>
    <p>状态: <span id="status">正在加载 AI 模型...</span></p>
    <p>提示: 握拳(合拢) | 张手(散开) | 抓取(放大照片)</p>
</div>

<div class="controls">
    <input type="file" id="photo-upload" accept="image/*" multiple style="display:none">
    <label for="photo-upload">上传圣诞照片</label>
</div>

<div id="video-container">
    <video id="input-video"></video>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/shaders/CopyShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/libs/tween.module.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script type="module">
    import * as TWEEN from 'https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@23.1.1/dist/tween.esm.js';

    // --- 全局变量与配置 ---
    let scene, camera, renderer, composer, clock;
    let particleSystem, photoCloud = [];
    let handTracker;
    let currentState = 'CLOSED'; // CLOSED, OPEN, ZOOMED
    const PARTICLE_COUNT = 2000;
    const colors = {
        green: new THREE.Color(0x1a331a),
        gold: new THREE.Color(0xd4af37),
        red: new THREE.Color(0x8b0000)
    };

    // --- 初始化 Three.js ---
    function initScene() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050a05, 0.02);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 15);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        // 后期处理：辉光效果
        const renderScene = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        clock = new THREE.Clock();
        
        const light = new THREE.PointLight(0xd4af37, 2, 50);
        light.position.set(0, 10, 5);
        scene.add(light);
    }

    // --- 创建粒子圣诞树 ---
    function createChristmasTree() {
        const geometries = [
            new THREE.SphereGeometry(0.1, 8, 8),
            new THREE.BoxGeometry(0.1, 0.1, 0.1),
            new THREE.CylinderGeometry(0.02, 0.02, 0.4) // 模拟糖果棍
        ];

        const material = new THREE.MeshStandardMaterial({ 
            metalness: 0.8, 
            roughness: 0.2, 
            vertexColors: true 
        });

        // 使用 InstancedMesh 提高性能
        particleSystem = new THREE.Group();
        
        const instMesh = new THREE.InstancedMesh(geometries[0], material, PARTICLE_COUNT);
        const matrix = new THREE.Matrix4();
        const colorArr = new Float32Array(PARTICLE_COUNT * 3);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // 定义两种坐标：树形态（圆锥螺旋）和 散开态（随机球体）
            const ratio = i / PARTICLE_COUNT;
            const angle = ratio * Math.PI * 40;
            const radius = (1 - ratio) * 5;
            
            // 目标位置1：树
            const targetX = Math.cos(angle) * radius;
            const targetY = ratio * 12 - 5;
            const targetZ = Math.sin(angle) * radius;

            // 存储到自定义属性
            const treePos = new THREE.Vector3(targetX, targetY, targetZ);
            const scatterPos = new THREE.Vector3(
                (Math.random() - 0.5) * 30,
                (Math.random() - 0.5) * 30,
                (Math.random() - 0.5) * 30
            );

            matrix.setPosition(treePos);
            instMesh.setMatrixAt(i, matrix);

            // 设置颜色
            const color = i % 3 === 0 ? colors.gold : (i % 3 === 1 ? colors.green : colors.red);
            instMesh.setColorAt(i, color);
            
            // 绑定动画属性到实例对象以便访问
            if(!instMesh.userData.positions) instMesh.userData.positions = [];
            instMesh.userData.positions.push({ tree: treePos, scatter: scatterPos, current: treePos.clone() });
        }

        scene.add(instMesh);
        particleSystem.mainMesh = instMesh;
    }

    // --- 处理照片上传与显示 ---
    document.getElementById('photo-upload').addEventListener('change', (e) => {
        const files = e.target.files;
        for(let file of files) {
            const url = URL.createObjectURL(file);
            const texture = new THREE.TextureLoader().load(url);
            const geometry = new THREE.PlaneGeometry(2, 2);
            const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geometry, material);
            
            mesh.position.set((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10);
            mesh.userData.treePos = mesh.position.clone();
            mesh.userData.scatterPos = new THREE.Vector3((Math.random()-0.5)*20, (Math.random()-0.5)*20, (Math.random()-0.5)*20);
            
            scene.add(mesh);
            photoCloud.push(mesh);
        }
    });

    // --- 状态切换动画 ---
    function transitionTo(state) {
        if (currentState === state) return;
        currentState = state;
        document.getElementById('status').innerText = state;

        const mesh = particleSystem.mainMesh;
        const duration = 1500;

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const posData = mesh.userData.positions[i];
            const target = state === 'CLOSED' ? posData.tree : posData.scatter;
            
            new TWEEN.Tween(posData.current)
                .to({ x: target.x, y: target.y, z: target.z }, duration + Math.random() * 1000)
                .easing(TWEEN.Easing.Elastic.Out)
                .start();
        }

        photoCloud.forEach(p => {
            const target = state === 'CLOSED' ? p.userData.treePos : p.userData.scatterPos;
            new TWEEN.Tween(p.position).to({ x: target.x, y: target.y, z: target.z }, duration).start();
        });
    }

    // --- AI 手势追踪 ---
    async function initHandTracking() {
        const videoElement = document.getElementById('input-video');
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults(onHandResults);

        const cameraPipe = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 640,
            height: 480
        });
        cameraPipe.start();
    }

    function onHandResults(results) {
        if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;
        
        const landmarks = results.multiHandLandmarks[0];
        
        // 1. 判断是否握拳 (Fist)
        const isFist = detectFist(landmarks);
        // 2. 判断是否张开 (Open Palm)
        const isOpen = detectOpen(landmarks);
        // 3. 获取手部中心点用于控制相机
        const handCenter = landmarks[9]; // 中指根部

        if (isFist) {
            transitionTo('CLOSED');
        } else if (isOpen) {
            transitionTo('OPEN');
        }

        // 4. 相机平滑旋转控制
        const targetRotY = (handCenter.x - 0.5) * Math.PI * 2;
        const targetRotX = (handCenter.y - 0.5) * Math.PI;
        camera.position.x += (Math.sin(targetRotY) * 15 - camera.position.x) * 0.05;
        camera.position.z += (Math.cos(targetRotY) * 15 - camera.position.z) * 0.05;
        camera.lookAt(0, 0, 0);

        // 5. 抓取动作逻辑（放大最近的照片）
        if (detectGrab(landmarks) && photoCloud.length > 0) {
            zoomToPhoto(photoCloud[0]); // 示例：抓取第一张
        }
    }

    // 基础手势识别算法
    function detectFist(lm) {
        const dist = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
        return dist < 0.2; 
    }

    function detectOpen(lm) {
        const dist = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
        return dist > 0.5;
    }

    function detectGrab(lm) {
        const thumbTip = lm[4];
        const indexTip = lm[8];
        return Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y) < 0.05;
    }

    function zoomToPhoto(mesh) {
        new TWEEN.Tween(camera.position)
            .to({ x: mesh.position.x, y: mesh.position.y, z: mesh.position.z + 5 }, 1000)
            .start();
    }

    // --- 渲染循环 ---
    function animate() {
        requestAnimationFrame(animate);
        TWEEN.update();

        // 更新 InstancedMesh 矩阵
        if (particleSystem.mainMesh) {
            const mesh = particleSystem.mainMesh;
            const matrix = new THREE.Matrix4();
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const pos = mesh.userData.positions[i].current;
                matrix.setPosition(pos);
                mesh.setMatrixAt(i, matrix);
            }
            mesh.instanceMatrix.needsUpdate = true;
            mesh.rotation.y += 0.002; // 缓慢自转
        }

        composer.render();
    }

    // --- 启动 ---
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    });

    initScene();
    createChristmasTree();
    initHandTracking();
    animate();
    
    // 初始状态提示
    setTimeout(() => {
        document.getElementById('status').innerText = "AI 就绪：尝试伸掌或握拳";
    }, 3000);

</script>
</body>
</html>