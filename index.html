<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Xmas-Vision Pro: 雪夜幻境</title>
    <style>
        :root {
            --gold: #d4af37;
            --deep-green: #050a05;
        }
        body { margin: 0; overflow: hidden; background: var(--deep-green); font-family: -apple-system, sans-serif; }
        canvas { display: block; touch-action: none; }

        /* UI 叠加层 */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }

        .header {
            padding: 30px; text-align: center; color: var(--gold);
            letter-spacing: 3px; text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }

        .controls {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; pointer-events: auto;
        }

        #close-btn {
            position: absolute; top: 40px; right: 30px;
            padding: 12px 25px; background: rgba(0,0,0,0.6);
            border: 1px solid var(--gold); color: var(--gold);
            border-radius: 25px; display: none; pointer-events: auto;
            backdrop-filter: blur(10px);
        }

        .upload-label {
            background: rgba(26, 51, 26, 0.8); border: 1px solid var(--gold);
            color: var(--gold); padding: 12px 25px; border-radius: 25px;
            font-size: 14px; backdrop-filter: blur(10px);
        }

        #video-preview {
            position: absolute; bottom: 20px; right: 20px;
            width: 70px; height: 90px; border: 1px solid var(--gold);
            border-radius: 8px; overflow: hidden; transform: scaleX(-1);
        }
        video { width: 100%; height: 100%; object-fit: cover; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="header">
        <div style="font-size: 1.4rem;">SHINING NIGHT</div>
        <div id="status-text" style="font-size: 0.7rem; margin-top: 5px; opacity: 0.7;">正在启动 AI 视觉...</div>
    </div>

    <button id="close-btn">返回视图</button>

    <div class="controls">
        <input type="file" id="file-input" accept="image/*" multiple style="display:none">
        <label for="file-input" class="upload-label">上传本地照片</label>
    </div>
</div>

<div id="video-preview">
    <video id="webcam" playsinline></video>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@23.1.1/dist/tween.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
    let scene, camera, renderer, clock;
    let treeParticles, snowSystem;
    let photoMeshes = [];
    let currentMode = 'TREE'; // TREE, SCATTER, ZOOMED
    let zoomedObject = null;

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // --- 初始化 ---
    function init() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050a05, 0.02);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 20);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        clock = new THREE.Clock();

        addLights();
        createTreeParticles();
        createSnow();
        
        window.addEventListener('resize', onResize);
        window.addEventListener('pointerdown', onPointerDown);
        document.getElementById('close-btn').addEventListener('click', exitZoom);
    }

    function addLights() {
        const ambient = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambient);
        const pointLight = new THREE.PointLight(0xd4af37, 2, 50);
        pointLight.position.set(0, 10, 10);
        scene.add(pointLight);
    }

    // --- 圣诞树粒子 ---
    function createTreeParticles() {
        const count = 2000;
        const geom = new THREE.SphereGeometry(0.07, 6, 6);
        const mat = new THREE.MeshStandardMaterial({ metalness: 0.8, roughness: 0.2, vertexColors: true });
        treeParticles = new THREE.InstancedMesh(geom, mat, count);

        const treePos = [], scatterPos = [], currentPos = [];
        const dummy = new THREE.Object3D();

        for (let i = 0; i < count; i++) {
            const t = i / count;
            const angle = t * Math.PI * 30;
            const radius = (1 - t) * 6;
            const p = new THREE.Vector3(Math.cos(angle)*radius, t*15-5, Math.sin(angle)*radius);
            treePos.push(p);
            currentPos.push(p.clone());
            scatterPos.push(new THREE.Vector3((Math.random()-0.5)*30, (Math.random()-0.5)*30, (Math.random()-0.5)*30));
            
            const color = new THREE.Color();
            color.setHSL(Math.random() > 0.8 ? 0.1 : 0.3, 0.7, 0.5); // 金/绿切换
            treeParticles.setColorAt(i, color);
        }

        treeParticles.userData = { treePos, scatterPos, currentPos };
        scene.add(treeParticles);
    }

    // --- 雪花系统 ---
    function createSnow() {
        const count = 1500;
        const vertices = [];
        const velocities = [];
        for (let i = 0; i < count; i++) {
            vertices.push((Math.random()-0.5)*40, Math.random()*40, (Math.random()-0.5)*40);
            velocities.push(Math.random()*0.05 + 0.02);
        }
        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.08, transparent: true, opacity: 0 });
        snowSystem = new THREE.Points(geo, mat);
        scene.add(snowSystem);
    }

    // --- 照片处理与点击 ---
    document.getElementById('file-input').addEventListener('change', (e) => {
        const files = Array.from(e.target.files);
        files.forEach(file => {
            const url = URL.createObjectURL(file);
            new THREE.TextureLoader().load(url, (tex) => {
                const aspect = tex.image.width / tex.image.height;
                const mesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(3 * aspect, 3),
                    new THREE.MeshStandardMaterial({ map: tex, side: THREE.DoubleSide })
                );
                // 金色边框
                const border = new THREE.Mesh(
                    new THREE.PlaneGeometry(3.15 * aspect, 3.15),
                    new THREE.MeshBasicMaterial({ color: 0xd4af37, side: THREE.BackSide })
                );
                mesh.add(border);
                mesh.position.set((Math.random()-0.5)*15, (Math.random()-0.5)*15, (Math.random()-0.5)*10);
                mesh.userData.originalPos = mesh.position.clone();
                scene.add(mesh);
                photoMeshes.push(mesh);
            });
        });
    });

    function onPointerDown(e) {
        if (currentMode === 'ZOOMED') return;
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(photoMeshes);
        if (intersects.length > 0) {
            zoomToPhoto(intersects[0].object);
        }
    }

    function zoomToPhoto(obj) {
        currentMode = 'ZOOMED';
        zoomedObject = obj;
        document.getElementById('close-btn').style.display = 'block';

        // 计算相机正前方的目标位置
        const targetPos = new THREE.Vector3(0, 0, 10).applyQuaternion(camera.quaternion).add(camera.position);
        
        new TWEEN.Tween(obj.position).to({ x: targetPos.x, y: targetPos.y, z: targetPos.z }, 1000)
            .easing(TWEEN.Easing.Cubic.Out).start();
        new TWEEN.Tween(obj.rotation).to({ x: camera.rotation.x, y: camera.rotation.y, z: camera.rotation.z }, 1000).start();
        
        // 背景变暗/虚化
        new TWEEN.Tween(treeParticles.material).to({ opacity: 0.2 }, 500).start();
    }

    function exitZoom() {
        if (!zoomedObject) return;
        new TWEEN.Tween(zoomedObject.position).to({ 
            x: zoomedObject.userData.originalPos.x, 
            y: zoomedObject.userData.originalPos.y, 
            z: zoomedObject.userData.originalPos.z 
        }, 800).easing(TWEEN.Easing.Cubic.In).start();
        
        document.getElementById('close-btn').style.display = 'none';
        currentMode = 'SCATTER';
        zoomedObject = null;
    }

    // --- AI 与 动画控制 ---
    function setMode(mode) {
        if (currentMode === mode || currentMode === 'ZOOMED') return;
        currentMode = mode;
        const targets = mode === 'TREE' ? treeParticles.userData.treePos : treeParticles.userData.scatterPos;
        
        treeParticles.userData.currentPos.forEach((p, i) => {
            new TWEEN.Tween(p).to({ x: targets[i].x, y: targets[i].y, z: targets[i].z }, 1500).start();
        });

        // 雪花显隐控制
        new TWEEN.Tween(snowSystem.material).to({ opacity: mode === 'SCATTER' ? 0.8 : 0 }, 1000).start();
    }

    async function initAI() {
        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5 });
        hands.onResults(res => {
            if (!res.multiHandLandmarks || res.multiHandLandmarks.length === 0) return;
            const lm = res.multiHandLandmarks[0];
            const dist = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
            if (dist < 0.3) setMode('TREE');
            else if (dist > 0.5) setMode('SCATTER');
        });

        const cam = new Camera(document.getElementById('webcam'), {
            onFrame: async () => { await hands.send({ image: document.getElementById('webcam') }); },
            width: 480, height: 640
        });
        cam.start();
        document.getElementById('status-text').innerText = "AI 视觉已激活：握拳合拢 / 张手散开";
    }

    function animate() {
        requestAnimationFrame(animate);
        TWEEN.update();
        const delta = clock.getDelta();

        // 更新树粒子矩阵
        const dummy = new THREE.Object3D();
        treeParticles.userData.currentPos.forEach((p, i) => {
            dummy.position.copy(p);
            dummy.updateMatrix();
            treeParticles.setMatrixAt(i, dummy.matrix);
        });
        treeParticles.instanceMatrix.needsUpdate = true;

        // 雪花下落逻辑
        if (snowSystem.material.opacity > 0.01) {
            const positions = snowSystem.geometry.attributes.position.array;
            for (let i = 1; i < positions.length; i += 3) {
                positions[i] -= 0.05; // 下落
                positions[i-1] += Math.sin(clock.getElapsedTime() + i) * 0.01; // 摆动
                if (positions[i] < -10) positions[i] = 30; // 循环
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
        }

        // 散开态下的照片自动旋转
        if (currentMode === 'SCATTER') {
            photoMeshes.forEach((m, i) => {
                m.rotation.y += 0.005;
                m.position.y += Math.sin(clock.getElapsedTime() + i) * 0.005;
            });
        }

        renderer.render(scene, camera);
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    init();
    initAI();
    animate();
</script>
</body>
</html>