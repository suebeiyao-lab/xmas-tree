<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Golden Dream Xmas</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@23.1.1/dist/tween.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        body { margin: 0; background: #020502; overflow: hidden; }
        #start-screen { position: fixed; inset: 0; background: radial-gradient(circle, #1a1a00, #000); z-index: 1000; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #d4af37; }
        #start-btn { padding: 15px 50px; background: #d4af37; border: none; border-radius: 40px; font-weight: bold; font-size: 1.2rem; cursor: pointer; box-shadow: 0 0 20px rgba(212,175,55,0.5); }
        #webcam-wrap { position: absolute; bottom: 15px; right: 15px; width: 90px; height: 120px; border: 1px solid #d4af37; border-radius: 10px; overflow: hidden; transform: scaleX(-1); opacity: 0.8; }
        video { width: 100%; height: 100%; object-fit: cover; }
        #ui { position: absolute; top: 20px; width: 100%; text-align: center; color: #d4af37; pointer-events: none; }
        .upload-area { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); }
        .btn { background: rgba(0,0,0,0.6); border: 1px solid #d4af37; color: #d4af37; padding: 10px 25px; border-radius: 30px; backdrop-filter: blur(5px); }
    </style>
</head>
<body>

<div id="start-screen">
    <h1 style="letter-spacing: 5px;">GOLDEN NIGHT</h1>
    <button id="start-btn">开启圣诞幻境</button>
</div>

<div id="ui">
    <div style="font-size: 1.5rem; font-weight: bold;">CHRISTMAS VISION</div>
    <div id="status" style="font-size: 10px; opacity: 0.6;">手势感应已就绪</div>
</div>

<div id="webcam-wrap"><video id="webcam" playsinline muted></video></div>
<div class="upload-area">
    <input type="file" id="file-in" multiple style="display:none">
    <button class="btn" onclick="document.getElementById('file-in').click()">上传回忆瞬间</button>
</div>

<script>
let scene, camera, renderer, treeGroup, particles, photoMeshes = [];
let targetRot = { x: 0, y: 0 }, mouse = new THREE.Vector2();

// 生成一个圆形发光贴图（不需要外部文件，直接 Canvas 生成）
function createSparkleTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
    grad.addColorStop(0, 'rgba(255,255,255,1)');
    grad.addColorStop(0.2, 'rgba(255,230,150,0.8)');
    grad.addColorStop(0.5, 'rgba(100,50,0,0.3)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 64, 64);
    const tex = new THREE.CanvasTexture(canvas);
    return tex;
}

function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1000);
    camera.position.set(0, 8, 28);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    treeGroup = new THREE.Group();
    scene.add(treeGroup);

    // --- 核心：构建茂密的华丽圣诞树 ---
    const count = 6000; // 粒子数量翻倍，更厚实
    const pos = new Float32Array(count * 3);
    const colors = new Float32Array(count * 3);
    const sizes = new Float32Array(count);

    for(let i=0; i<count; i++) {
        // 使用非线性分布，让树心更实
        const t = Math.pow(i / count, 0.6); 
        const angle = i * 0.25; // 黄金螺旋
        const radius = (1 - t) * 10 * (0.7 + Math.random() * 0.3);
        
        pos[i*3] = Math.cos(angle) * radius;
        pos[i*3+1] = t * 20 - 8;
        pos[i*3+2] = Math.sin(angle) * radius;

        // 颜色渐变：树顶更亮更金，底部更红更深
        const mixColor = new THREE.Color();
        const gold = new THREE.Color(0xffd700);
        const red = new THREE.Color(0xff2200);
        mixColor.lerpColors(red, gold, t + (Math.random()-0.5)*0.2);
        
        colors[i*3] = mixColor.r;
        colors[i*3+1] = mixColor.g;
        colors[i*3+2] = mixColor.b;
        
        sizes[i] = Math.random() * 0.5 + 0.1;
    }

    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    const mat = new THREE.PointsMaterial({
        size: 0.4,
        map: createSparkleTexture(), // 使用光晕贴图
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        transparent: true,
        depthWrite: false
    });

    particles = new THREE.Points(geo, mat);
    treeGroup.add(particles);

    // 顶部的亮星
    const starGeo = new THREE.SphereGeometry(0.8, 16, 16);
    const starMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const star = new THREE.Mesh(starGeo, starMat);
    star.position.y = 12.5;
    treeGroup.add(star);

    animate();
}

// 照片上传逻辑
document.getElementById('file-in').onchange = (e) => {
    const files = Array.from(e.target.files);
    files.forEach(file => {
        const url = URL.createObjectURL(file);
        new THREE.TextureLoader().load(url, (tex) => {
            const mesh = new THREE.Mesh(
                new THREE.PlaneGeometry(5, 5),
                new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide })
            );
            // 将照片环绕在树身
            const angle = Math.random() * Math.PI * 2;
            const h = Math.random() * 15 - 5;
            const r = (1 - (h+5)/20) * 10;
            mesh.position.set(Math.cos(angle)*r, h, Math.sin(angle)*r);
            mesh.lookAt(0, h, 0);
            mesh.userData.origin = mesh.position.clone();
            treeGroup.add(mesh);
            photoMeshes.push(mesh);
        });
    });
};

async function start() {
    const video = document.getElementById('webcam');
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;
        await video.play();

        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 0 });
        hands.onResults(res => {
            if (res.multiHandLandmarks && res.multiHandLandmarks[0]) {
                const lm = res.multiHandLandmarks[0];
                targetRot.y = (lm[9].x - 0.5) * 3;
                targetRot.x = (lm[9].y - 0.5) * 1.5;
            }
        });
        const cam = new Camera(video, { onFrame: async () => { await hands.send({ image: video }); } });
        cam.start();
        document.getElementById('start-screen').style.display = 'none';
    } catch(e) { alert("请确保开启摄像头权限并使用 HTTPS 访问"); }
}

function animate() {
    requestAnimationFrame(animate);
    TWEEN.update();
    if(treeGroup) {
        treeGroup.rotation.y += (targetRot.y - treeGroup.rotation.y) * 0.05;
        treeGroup.rotation.x += (targetRot.x - treeGroup.rotation.x) * 0.05;
        // 微弱的自转，增加动态感
        treeGroup.rotation.y += 0.002;
    }
    renderer.render(scene, camera);
}

window.onload = init;
document.getElementById('start-btn').onclick = start;
</script>
</body>
</html>